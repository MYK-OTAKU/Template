import React, { createContext, useContext, useState, useEffect, useCallback, useRef } from 'react';
import { useNavigate, useLocation } from 'react-router-dom';
import authService from '../services/authService';
import { useNotification } from '../hooks/useNotification';

// AuthContext pour la gestion de l'authentification
import { isTokenExpired, getTokenExpiryDate } from '../utils/tokenUtils';

const AuthContext = createContext(null);

export const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  const [isAuthenticated, setIsAuthenticated] = useState(false);
  const [twoFactorRequired, setTwoFactorRequired] = useState(false);
  const [tempAuthData, setTempAuthData] = useState(null);
  const [token, setToken] = useState(null);
  const [initialAuthCheckComplete, setInitialAuthCheckComplete] = useState(false);
  const [sessionExpiresAt, setSessionExpiresAt] = useState(null);

  const navigate = useNavigate();
  const location = useLocation();
  const { showSessionExpired } = useNotification();
  
  // Suppression des r√©f√©rences √† showToast - maintenant g√©r√© par le syst√®me de notifications
  
  // ‚úÖ Refs pour √©viter les boucles infinies
  const isInitializing = useRef(false);
  const loginInProgress = useRef(false);
  const redirectionHandled = useRef(false);

  // ‚úÖ Surveillance de l'expiration du token
  useEffect(() => {
    if (token && isAuthenticated) {
      const expiryDate = getTokenExpiryDate(token);
      setSessionExpiresAt(expiryDate);
      
      const checkTokenExpiry = () => {
        if (isTokenExpired(token)) {
          console.log('üîí [AUTH_CONTEXT] Token expir√© d√©tect√©');
          clearAuthState();
          showSessionExpired();
          navigate('/', { replace: true });
        }
      };
      
      const intervalId = setInterval(checkTokenExpiry, 30000);
      return () => clearInterval(intervalId);
    } else {
      setSessionExpiresAt(null);
    }
  }, [token, isAuthenticated]);

  // Fonction pour nettoyer l'√©tat d'authentification
  const clearAuthState = useCallback(() => {
    console.log('üßπ [AUTH_CONTEXT] Nettoyage de l\'√©tat d\'authentification');
    setUser(null);
    setIsAuthenticated(false);
    setTwoFactorRequired(false);
    setTempAuthData(null);
    setToken(null);
    setSessionExpiresAt(null);
    redirectionHandled.current = false;
    authService.clearAuthData();
  }, []);

  // ‚úÖ CORRECTION CRITIQUE: Gestion centralis√©e des redirections
  useEffect(() => {
    if (!initialAuthCheckComplete || loading) return;

    // ‚úÖ √âviter les redirections multiples
    if (redirectionHandled.current) return;

    console.log('üîç [AUTH_CONTEXT] Gestion des redirections:', {
      pathname: location.pathname,
      isAuthenticated,
      user: !!user,
      twoFactorRequired,
      tempAuthData: !!tempAuthData
    });

    // ‚úÖ Cas 1: Utilisateur compl√®tement authentifi√© - rediriger vers dashboard
    if (isAuthenticated && user && !twoFactorRequired) {
      if (location.pathname === '/' || location.pathname === '/verify-2fa') {
        console.log('‚úÖ [AUTH_CONTEXT] Redirection vers dashboard');
        redirectionHandled.current = true;
        navigate('/dashboard', { replace: true });
        return;
      }
    }

    // ‚úÖ CORRECTION: Cas 2: 2FA requis - rediriger vers page 2FA
    if (twoFactorRequired && tempAuthData?.tempToken && !isAuthenticated) {
      if (location.pathname !== '/verify-2fa') { // ‚úÖ Condition corrig√©e
        console.log('‚úÖ [AUTH_CONTEXT] Redirection vers 2FA');
        redirectionHandled.current = true;
        navigate('/verify-2fa', { replace: true }); // ‚úÖ Route corrig√©e
        return;
      }
    }

    // ‚úÖ Cas 3: Pas d'authentification - rediriger vers login
    if (!isAuthenticated && !twoFactorRequired && !tempAuthData) {
      if (location.pathname !== '/') {
        console.log('‚úÖ [AUTH_CONTEXT] Redirection vers login');
        redirectionHandled.current = true;
        navigate('/', { replace: true });
        return;
      }
    }

  }, [initialAuthCheckComplete, loading, isAuthenticated, user, twoFactorRequired, tempAuthData, location.pathname, navigate]);

  // ‚úÖ Initialisation au montage
  useEffect(() => {
    const initAuth = async () => {
      if (isInitializing.current) return;
      isInitializing.current = true;

      console.log('üîÑ [AUTH_CONTEXT] Initialisation de l\'authentification...');
      try {
        setLoading(true);
        authService.init();
        
        if (authService.isAuthenticated()) {
          const currentUser = authService.getCurrentUser();
          const currentToken = authService.getToken();
          
          if (currentToken && !isTokenExpired(currentToken)) {
            console.log('‚úÖ [AUTH_CONTEXT] Utilisateur d√©j√† connect√©:', currentUser?.username);
            setUser(currentUser);
            setToken(currentToken);
            setIsAuthenticated(true);
            setTwoFactorRequired(false);
            setTempAuthData(null);
          } else {
            console.log('üîí [AUTH_CONTEXT] Token expir√©, nettoyage');
            clearAuthState();
          }
        } else {
          console.log('‚ùå [AUTH_CONTEXT] Aucune session active trouv√©e');
          clearAuthState();
        }
      } catch (error) {
        console.error('‚ùå [AUTH_CONTEXT] Erreur lors de l\'initialisation:', error);
        clearAuthState();
      } finally {
        setLoading(false);
        setInitialAuthCheckComplete(true);
        isInitializing.current = false;
        console.log('‚úÖ [AUTH_CONTEXT] Initialisation termin√©e');
      }
    };

    initAuth();
  }, []);

  // √âcouter les √©v√©nements d'expiration de session
  useEffect(() => {
    const handleSessionExpired = (event) => {
      console.log('üîí [AUTH_CONTEXT] Session expir√©e re√ßue:', event.detail);
      clearAuthState();
      showSessionExpired();
      
      if (!location.pathname.includes('/')) {
        navigate('/', { replace: true });
      }
    };

    window.addEventListener('auth:sessionExpired', handleSessionExpired);
    
    return () => {
      window.removeEventListener('auth:sessionExpired', handleSessionExpired);
    };
  }, [clearAuthState, showSessionExpired, navigate, location.pathname]);

  // ‚úÖ CORRECTION: Fonction de connexion avec qrCodeUrl
  const login = useCallback(async (credentials) => {
    if (loginInProgress.current) {
      console.log('üîÑ [AUTH_CONTEXT] Connexion d√©j√† en cours, ignor√©e');
      return;
    }

    loginInProgress.current = true;
    redirectionHandled.current = false;
    
    console.log('üîê [AUTH_CONTEXT] Tentative de connexion pour:', credentials.username);
    
    try {
      setLoading(true);
      const response = await authService.login(credentials);
      
      console.log('üì° [AUTH_CONTEXT] R√©ponse de connexion:', response);
      
      // ‚úÖ Cas 2FA requis - MISE √Ä JOUR pour les nouveaux champs
      if (response.success && response.requireTwoFactor) {
        console.log('üîí [AUTH_CONTEXT] 2FA requis');
        console.log('üîç [AUTH_CONTEXT] R√©ponse 2FA compl√®te:', {
          tempToken: !!response.tempToken,
          userId: response.userId,
          message: response.message,
          qrCodeUrl: response.qrCodeUrl,
          qrCodeExists: !!response.qrCodeUrl,
          // ‚úÖ NOUVEAUX CHAMPS
          manualEntryKey: response.manualEntryKey,
          isNewSetup: response.isNewSetup,
          setupReason: response.setupReason,
          requiresNewConfiguration: response.requiresNewConfiguration
        });

        setTwoFactorRequired(true);
        setTempAuthData({
          tempToken: response.tempToken,
          userId: response.userId,
          message: response.message,
          qrCodeUrl: response.qrCodeUrl,
          // ‚úÖ AJOUT DES NOUVEAUX CHAMPS
          manualEntryKey: response.manualEntryKey,
          isNewSetup: response.isNewSetup || false,
          setupReason: response.setupReason || 'STANDARD',
          requiresNewConfiguration: response.requiresNewConfiguration || false
        });
        setIsAuthenticated(false);                                                                                                                                                                                                                                                                                                                                                        
        setUser(null);
        setToken(null);
        return response;
      }
      
      // ‚úÖ Connexion r√©ussie sans 2FA
      if (response.success && response.token && response.user) {
        console.log('‚úÖ [AUTH_CONTEXT] Connexion r√©ussie sans 2FA pour:', response.user.username);
        
        const currentUser = authService.getCurrentUser();
        const currentToken = authService.getToken();
        
        setUser(currentUser);
        setToken(currentToken);
        setIsAuthenticated(true);
        setTwoFactorRequired(false);
        setTempAuthData(null);
        
        return response;
      }
      
      throw new Error('R√©ponse de connexion invalide du serveur');
      
    } catch (error) {
      console.error('‚ùå [AUTH_CONTEXT] Erreur de connexion:', error);
      clearAuthState();
      throw error;
    } finally {
      setLoading(false);
      loginInProgress.current = false;
    }
  }, [clearAuthState]);

  // ‚úÖ CORRECTION: Fonction de v√©rification 2FA simplifi√©e
  const verifyTwoFactor = useCallback(async (twoFactorCode) => {
    console.log('üîê [AUTH_CONTEXT] V√©rification 2FA...');
    redirectionHandled.current = false;
    
    try {
      setLoading(true);
      
      if (!tempAuthData?.tempToken) {
        throw new Error("Token temporaire manquant pour la v√©rification 2FA");
      }
      
      const response = await authService.verifyTwoFactor(tempAuthData.tempToken, twoFactorCode);
      
      console.log('üì° [AUTH_CONTEXT] R√©ponse 2FA:', response);
      
      if (response.success && response.token && response.user) {
        console.log('‚úÖ [AUTH_CONTEXT] 2FA r√©ussie pour:', response.user.username);
        
        const currentUser = authService.getCurrentUser();
        const currentToken = authService.getToken();
        
        setUser(currentUser);
        setToken(currentToken);
        setIsAuthenticated(true);
        setTwoFactorRequired(false);
        setTempAuthData(null);
        
        return response;
      }
      
      throw new Error(response.message || '√âchec de la v√©rification 2FA');
      
    } catch (error) {
      console.error('‚ùå [AUTH_CONTEXT] Erreur 2FA:', error);
      throw error;
    } finally {
      setLoading(false);
    }
  }, [tempAuthData]);

  // Fonction de d√©connexion
  const logout = useCallback(async (reason = null) => {
    console.log('üö™ [AUTH_CONTEXT] D√©connexion, raison:', reason);
    
    try {
      await authService.logout();
    } catch (error) {
      console.error('‚ùå [AUTH_CONTEXT] Erreur lors de la d√©connexion:', error);
    } finally {
      clearAuthState();
      navigate('/', { replace: true });
    }
  }, [clearAuthState, navigate]);

  // Fonction de v√©rification de permission
  const hasPermission = useCallback((permission) => {
    console.group(`üîê [AUTH] V√©rification permission: ${permission}`);
    
    if (!user) {
      console.log('‚ùå Aucun utilisateur connect√©');
      console.groupEnd();
      return false;
    }

    if (!user.role) {
      console.log('‚ùå Utilisateur sans r√¥le');
      console.groupEnd();
      return false;
    }

    if (!user.role.permissions) {
      console.log('‚ùå R√¥le sans permissions');
      console.groupEnd();
      return false;
    }

    console.log('üë§ Utilisateur:', user.username);
    console.log('üé≠ R√¥le:', user.role.name);
    console.log('üìú Permissions disponibles:', user.role.permissions);

    // V√©rifier si c'est un admin (acc√®s total)
    const isAdmin = user.role.permissions.includes('ADMIN');
    if (isAdmin) {
      console.log('‚úÖ Acc√®s ADMIN - Permission accord√©e');
      console.groupEnd();
      return true;
    }

    // V√©rifier la permission sp√©cifique
    const hasSpecificPermission = user.role.permissions.includes(permission);
    console.log(`üîç Permission "${permission}":`, hasSpecificPermission);
    console.groupEnd();
    
    return hasSpecificPermission;
  }, [user]);

  // Fonction de v√©rification de r√¥le
  const hasRole = useCallback((roleName) => {
    return authService.hasRole(roleName);
  }, [user]);

  const value = {
    user,
    token,
    isAuthenticated,
    loading,
    loadingInitial: loading,
    initialAuthCheckComplete,
    twoFactorRequired,
    tempAuthData,
    sessionExpiresAt,
    login,
    logout,
    verifyTwoFactor,
    hasPermission,
    hasRole
  };

  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth doit √™tre utilis√© dans un AuthProvider');
  }
  return context;
};